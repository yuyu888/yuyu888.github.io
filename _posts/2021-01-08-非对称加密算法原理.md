---
layout: mypost
title: 非对称加密算法原理
categories: [算法思想]
---

### 玩个小游戏

> 你心中默念一个三位数，然后把它乘以23，把结果的后三位告诉我，我就能准确猜到你心中想的数字是几？

### 实验一下

假设你心中想的数字是231，那么 231*23=5313, 所以给应该给我数字就是 313 

那我拿到313这个数字该怎么办呢？

我用313 乘以87 得到 313*87=27231 这个数； 它的后三位就是 231， 神奇不？

这里你是不是会有疑问：

-  23、87这两个数是干嘛的？
-  23、87这两个数出现的依据是什么？为什么是这两个数？ 别的数行不行？

结合我们的题目，以及演算过程， 聪明如你一定能发现，23，87 不就是非对称加密的密钥对吗？23对应公钥；87对应私钥

为什么是23， 87；他们是怎么出来的？且看下文...

### 原理

我们把这两个数相乘， 得到 23*87=2001

任何一个三位数乘以2001，末尾三位都是该数本身； 比如 231*2001=462 231

假设三位数是num； 2001 = p * q; 那么 num * 2001 的后三位 等于 num

所以 num * p * q 的后三位 等于 num

假设 num  = (m1 * 1000) + m2; 那么

    num * p = （(m1 * 1000) + m2) * p = m1 * 1000 * p + m2 * p

假如 m1 = 0（没有千位）；

    num * p * q = m2 * p * q  
得到的数(m2 * p * q)的后三位 等于 num

假如 m1>0  那么 

    num * p * q = (m1 * 1000 + m2) * p * q = m1 * 1000 * p * q + m2 * p * q 

由于 m1 * 1000 * p * q 得到的数都在千位以上； 它的结果根本不影响最终数的后三位 所以
 m2 * p * q  的后三位值与 num * p * q 后三位值相等 都是 num

由此 我们可以认为 num 就是要加密的信息， p是公钥，q是私钥， m2 即是加密后的信息

一套完整的非对称加密逻辑就构建出来了

2001 的约数组合

First | second
|:--:|:--:|
3|667
23|87
29|69
69|29
87|23
667|3

我们这里只是取的 23，87 这对约数而已， 其实也可以使用29, 69这一对，或者其他组合

除了2001 其实1001、3001 ... 都可以 其实都1+n*1000 然后反向求约数

我们只用构造一个数然后求它的约数就行了

    公式：
    p * q =1+n*(1ek) // 1ek 即10的k次方

如果我们想加密5位 就 100001 还可以更长
10000000001 = 27961 * 357641

还可以更长， 比如 10000000000000000000000000000000001 
但是要求它的约数呢？ 是不是发现有点困难了？ 但是如果想尝试一下，其实也不是不可以求解

但是当你能求它的所有约数的时候， 其实就相当于能够穷举破解了；

我如果想要生成一组密钥对， 就得分解因式去求约数，求解困难不说，如果我求出来了， 意味着别人可以求出来， 直接把结果穷举出来就破解了， 好尴尬

所以 真实世界就不是使用乘法了，比如 RSA算法 使用的是指数和取模运算，但本质上就是上面这套思想。

### RSA算法

说明 | 描述 | 备注 | 例证
|:--|:--:|:--:|:--:|
找出质数 | P 、Q | - | P=3、 Q=11
计算公共模数 | N = P * Q | - | N=3*11=33
欧拉函数 | φ(N) = (P-1)(Q-1) | - | φ(N)=(3-1)*(11-1)=20
计算公钥E | 1 < E < φ(N) | E的取值必须是整数 <br/>E 和 φ(N) 必须是互质数 | 满足条件的集合{3, 7, 9, 11, 13, 17, 19}<br/> 取最小值 E=3
计算私钥D | E * D % φ(N) = 1 | - | 3*D%20=1；D=7
原始信息 | M | - | M=2
加密 | C ＝ M<sup>E</sup> mod N | C：密文<br/> M：明文 | C=2<sup>3</sup>%33=8
解密 | M ＝C<sup>D</sup> mod N | C：密文<br/> M：明文 | M=8<sup>7</sup>%33=2097152=2

公钥＝(E , N)  
私钥＝(D, N)

我只是搬运工

[RSA 算法原理（上）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html){:target="_blank"}

[RSA 算法原理（下）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html){:target="_blank"}

### 只是个巧合？
当在阐述RSA算法的时候， 看到 E * D % φ(N) = 1 这一步 有种眼前一亮的感觉  
结合文章开始的例子  
2001 % 1000 不就等于 1 吗？ 试着反向碰瓷一下， 看看能不能发现点啥？  
2001 = 23 * 87 那么 可以假设 E = 23； D = 87； φ(N) = 1000 = (P-1)(Q-1)   
假设 P = 41; Q = 51; N = P * Q = 2091  
至此 所有假设都符合 RSA的条件设定

那么 公钥＝(E , N) = (23, 2091)； 私钥 = (D, N) = (87, 2091) 设 明文 M = 231 

计算密文 C = M<sup>E</sup> mod N = 231<sup>23</sup>%2091 = 1161

解密秘文  M ＝C<sup>D</sup> mod N = 1161<sup>87</sup>%2091 = 231

成功完成了一次 加密，解密； 

通过生拉硬凑，得到的一组数据，通过不同的方式达到了同样的目的，看似有联系，又有点说不清联系在哪里，也许只是是个巧合？

如何计算 231<sup>23</sup>%2091 具体请看 [快速幂取模算法]()