---
layout: mypost
title: 非对称加密算法原理
categories: [算法思想]
---

### 玩个小游戏

> 你心中默念一个三位数，然后把它乘以23，把结果的后三位告诉我，我就能准确猜到你心中想的数字是几？

### 实验一下

假设你心中想的数字是231，那么 231*23=5313, 所以给应该给我数字就是 313 

那我拿到313这个数字该怎么办呢？

我用313 乘以87 得到 313*87=27213 这个数； 它的后三位就是 231， 神奇不？

这里你是不是会有疑问：

-  23、87这两个数是干嘛的？
-  23、87这两个数出现的依据是什么？为什么是这两个数？ 别的数行不行？

结合我们的题目，以及演算过程， 聪明如你一定能发现，23，87 不就是非对称加密的密钥对吗？23对应公钥；87对应私钥

为什么是23， 87；他们是怎么出来的？且看下文...

### 原理

我们把这两个数相乘， 得到 23*87=2001

任何一个三位数乘以2001，末尾三位都是该数本身； 比如 231*2001=462 231

假设三位数是num； 2001 = p * q; 那么 num * 2001 的后三位 等于 num

所以 num * p * q 的后三位 等于 num

假设 num  = (m1 * 1000) + m2; 那么

    num * p = （(m1 * 1000) + m2) * p = m1 * 1000 * p + m2 * p

假如 m1 = 0（没有千位）；

    num * p * q = m2 * p * q  
得到的数(m2 * p * q)的后三位 等于 num

假如 m1>0  那么 

    num * p * q = (m1 * 1000 + m2) * p * q = m1 * 1000 * p * q + m2 * p * q 

由于 m1 * 1000 * p * q 得到的数都在千位以上； 它的结果根本不影响最终数的后三位 所以
 m2 * p * q  的后三位值与 num * p * q 后三位值相等 都是 num

由此 我们可以认为 num 就是要加密的信息， p是公钥，q是私钥， m2 即是加密后的信息

一套完整的非对称加密逻辑就构建出来了

2001 的约数组合

First | second
|:--:|:--:|
3|667
23|87
29|69
69|29
87|23
667|3

我们这里只是取的 23，87 这对约数而已， 其实也可以使用29|69这一对，或者其他组合

除了2001 其实1001、3001 ... 都可以 其实都1+n*1000 然后反向求约数

我们只用构造一个数然后求它的约数就行了

    公式：
    p * q =1+n*(1ek) // 1ek 即10的k次方

如果我们想加密5位 就 100001 还可以更长
10000000001 = 27961 * 357641

还可以更长， 比如 10000000000000000000000000000000001 
但是要求它的约数呢？ 是不是发现有点困难了？ 但是如果想尝试一下，其实也不是不可以求解

但是当你能求它的所有约数的时候， 其实就相当于能够穷举破解了；

我如果想要生成一组密钥对， 就得分解因式去求约数，求解困难不说，如果我求出来了， 意味着别人可以求出来， 直接把结果穷举出来就破解了， 好尴尬

所以 真实世界就不是使用乘法了，比如 RSA算法 使用的是指数和取模运算，但本质上就是上面这套思想。

### RSA算法

我只是搬运工

[RSA 算法原理（上）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html){:target="_blank"}

[RSA 算法原理（下）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html){:target="_blank"}

