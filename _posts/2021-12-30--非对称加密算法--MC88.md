---
layout: mypost
title: 非对称加密算法--MC88
categories: [算法思想]
---

## 序言
之前学习了下RSA的算法原理， 心血来潮，自己设计了一套非对称加密算法，命名为--MC88； 核心就是用了模反元素特性，及RSA所依赖的大数不可分解

## 算法描述

说明 | 描述 | 备注 | 例证
|:--|:--:|:--:|:--:|
随机产生三个数 | P(质数)、Q、O | - | P=57、 Q=63、O=36
计算公共模数 | N = P * Q - 1 | - | N=57*63-1=3590
计算公钥 | E = Q * O | - | E = 63*36 = 2268
公钥对 | [E, N] | - | [2268, 3590]
私钥对 | [P, O, N] | - | [57, 36, 3590]
原始信息 | S | 小于N/O | S=77（小于100）
加密 | M = (S * E) % N | - | M=(77*2268)%3390=2316
解密 | S ＝((M*P)%N)/O | - | S=((2316*57)%3390)/36=77



程序实现
````
package main

import "fmt"

func main() {
	//随机一个质数
	P := 57
	//随机一个数
	Q := 63
	//随机一个数
	O := 36

	//计算模数N
	N := P*Q - 1
	fmt.Println(N)

	//生产公钥
	E := Q * O
	fmt.Println(E)

	//公钥对 [2268, 3590]
	//私钥[57, 36, 3590]

	//需要加密的数据, 不大于100（N/O）
	S := 77

	//生成密文
	M := (S * E) % N
	fmt.Println(M)

	//解密
	m := (M * P) % N
	fmt.Println(m)
	S = m / O
	fmt.Println(S)
}

````

## 思考
该算法完成之后， 兴奋了好一阵， 感觉这个算法构造很简单，依赖的基础跟RSA是一样的，那么安全性也有保障，但是计算量比RSA少了求幂运算，会极大减少计算量，理论上讲是一个很优秀的算法； 但是为什么这个算法没有公开出现呢？毕竟也很容易想到（我能想到，肯定有很多人都想到了）；所以怀疑很定有人研究过，但是由于其有重大缺陷而放弃了

过了两天，突然发现，这个算法有一个限制条件，就是 需要加密的明文，不能大于 N/O（第一次设计出来的时候忽略了这个条件）； 一旦把这个条件公开出来，相当于变相的暴露了O, 进一步暴露了P，Q； 被秒破； 而且明文远小于N；导致要加密同样长度的明文， 该算法的N要比RSA大很多， 太浪费N了

当然也可以不能么直白的暴露出来， 比如条件是： 需要加密的明文不能大于 N/KO - i； K，i 随机

这样的话安全性就有保障了； 但是可以加密的明文长度， 就进一步被压缩； 如果加密相同长度的明文， 需要构造的N比RSA长太多，这个问题并没有被改善；且安全性到底有多强未知（本人才疏学浅，暂时还无法给出破解难度的数学证明）

## 结语

综上，该算法算不上什么优秀的算法， 但是作为学习，还是可以有一定的参考意义， 对作者本人也是有一定的纪念意义；希望能让大家对非对称加密有更加深刻的思考和理解
